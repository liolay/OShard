package cn.ocoop.framework.jdbc.connection;

import cn.ocoop.framework.jdbc.datasource.NamedDataSource;
import cn.ocoop.framework.jdbc.datasource.RoutingDataSource;
import cn.ocoop.framework.jdbc.exception.MergedSQLException;
import cn.ocoop.framework.jdbc.execute.invocation.MethodInvocation;
import cn.ocoop.framework.jdbc.execute.invocation.MethodInvocationRecorder;
import cn.ocoop.framework.jdbc.spay.AbstractSpayConnection;
import cn.ocoop.framework.jdbc.statement.RoutingPrepareStatement;
import cn.ocoop.framework.jdbc.statement.RoutingStatement;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import lombok.Getter;

import javax.sql.DataSource;
import java.sql.*;
import java.util.List;
import java.util.Map;

/**
 * Created by liolay on 2017/12/5.
 */
public class RoutingConnection extends AbstractSpayConnection {
    @Getter
    private RoutingDataSource routingDataSource;
    private Map<String, ConnectionWrapper> dataSourceId_connection = Maps.newHashMap();
    private MethodInvocationRecorder invocationRecorder = new MethodInvocationRecorder();
    private MethodInvocation createMethodInvocation;
    private boolean autoCommit = true;
    private boolean closed = false;
    private boolean readOnly = false;
    private int isolationLevel = java.sql.Connection.TRANSACTION_READ_COMMITTED;

    public RoutingConnection(RoutingDataSource routingDataSource, MethodInvocation methodInvocation) {
        this.routingDataSource = routingDataSource;
        this.createMethodInvocation = methodInvocation;
    }


    @Override
    public Statement createStatement() throws SQLException {
        return new RoutingStatement(this, reference(null));
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return new RoutingStatement(this, reference(new Class[]{int.class, int.class}, resultSetType, resultSetConcurrency), resultSetType, resultSetConcurrency);
    }

    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return new RoutingStatement(this, reference(new Class[]{int.class, int.class, int.class}, resultSetType, resultSetConcurrency, resultSetHoldability), resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return new RoutingPrepareStatement(this, reference(new Class[]{String.class}, sql), sql);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return new RoutingPrepareStatement(this, reference(new Class[]{String.class, int.class, int.class}, sql, resultSetType, resultSetConcurrency), sql, resultSetType, resultSetConcurrency);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return new RoutingPrepareStatement(this, reference(new Class[]{String.class, int.class, int.class, int.class}, sql, resultSetType, resultSetConcurrency, resultSetHoldability), sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return new RoutingPrepareStatement(this, reference(new Class[]{int.class}, sql, autoGeneratedKeys), sql, autoGeneratedKeys);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return new RoutingPrepareStatement(this, reference(new Class[]{String.class, int[].class}, sql, columnIndexes), sql, columnIndexes);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return new RoutingPrepareStatement(this, reference(new Class[]{String.class, String[].class}, sql, columnNames), sql, columnNames);
    }

    @Override
    public boolean getAutoCommit() throws SQLException {
        return autoCommit;
    }

    @Override
    public void setAutoCommit(boolean autoCommit) throws SQLException {
        this.autoCommit = autoCommit;
        record(new Class[]{boolean.class}, autoCommit);
        for (ConnectionWrapper connection : dataSourceId_connection.values()) {
            connection.setAutoCommit(autoCommit);
        }
    }

    @Override
    public void commit() throws SQLException {
        //TODO 分布式事物解决
        MergedSQLException sqlException = new MergedSQLException();
        for (ConnectionWrapper connection : dataSourceId_connection.values()) {
            try {
                connection.commit();
            } catch (SQLException e) {
                sqlException.stack(e);
            }
        }
        if (sqlException.notEmpty()) throw sqlException;
    }

    @Override
    public void rollback() throws SQLException {
        MergedSQLException sqlException = new MergedSQLException();
        for (ConnectionWrapper connection : dataSourceId_connection.values()) {
            try {
                if (!connection.getAutoCommit()) {
                    connection.rollback();
                }
            } catch (SQLException e) {
                sqlException.stack(e);
            }
        }
        if (sqlException.notEmpty()) throw sqlException;
    }

    @Override
    public void close() throws SQLException {
        this.closed = true;
        MergedSQLException sqlException = new MergedSQLException();
        for (ConnectionWrapper connection : dataSourceId_connection.values()) {
            try {
                connection.close();
            } catch (SQLException e) {
                sqlException.stack(e);
            }
        }
        invocationRecorder.clear();
        dataSourceId_connection.clear();
        if (sqlException.notEmpty()) throw sqlException;
    }

    @Override
    public boolean isClosed() throws SQLException {
        return this.closed;
    }

    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
        ConnectionWrapper connection = null;
        if (dataSourceId_connection.isEmpty()) {
            Map.Entry<String, DataSource> dataSourceEntry = routingDataSource.getDataSources().entrySet().iterator().next();
            NamedDataSource namedDataSource = new NamedDataSource(dataSourceEntry.getKey(), dataSourceEntry.getValue());
            Connection orgConnection = (Connection) createMethodInvocation.invoke(namedDataSource);
            connection = new ConnectionWrapper(namedDataSource, orgConnection);
            invocationRecorder.replay(connection);
            ConnectionWrapper existConnection = dataSourceId_connection.putIfAbsent(namedDataSource.getName(), connection);
            if (existConnection != null) {
                connection = existConnection;
            }
        }

        return connection.getMetaData();
    }

    @Override
    public boolean isReadOnly() throws SQLException {
        return this.readOnly;
    }

    @Override
    public void setReadOnly(boolean readOnly) throws SQLException {
        this.readOnly = readOnly;
        record(new Class[]{boolean.class}, readOnly);
        for (ConnectionWrapper connection : dataSourceId_connection.values()) {
            connection.setReadOnly(readOnly);
        }
    }

    @Override
    public int getTransactionIsolation() throws SQLException {
        return isolationLevel;
    }

    @Override
    public void setTransactionIsolation(int level) throws SQLException {
        this.isolationLevel = level;
        record(new Class[]{int.class}, level);
        for (ConnectionWrapper connection : dataSourceId_connection.values()) {
            connection.setTransactionIsolation(level);
        }
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        SQLWarning sqlWarning = null;
        for (ConnectionWrapper connection : dataSourceId_connection.values()) {
            SQLWarning warnings = connection.getWarnings();
            if (warnings != null) {
                if (sqlWarning == null) {
                    sqlWarning = new SQLWarning();
                }
                sqlWarning.setNextWarning(warnings);
            }
        }
        return sqlWarning;
    }

    @Override
    public void clearWarnings() throws SQLException {
        for (ConnectionWrapper connection : dataSourceId_connection.values()) {
            connection.clearWarnings();
        }
    }

    @Override
    public int getHoldability() throws SQLException {
        return java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT;
    }

    @Override
    public void setHoldability(int holdability) throws SQLException {

    }

    private List<ConnectionWrapper> route(List<NamedDataSource> dataSources) {
        List<ConnectionWrapper> targetConnection = Lists.newArrayList();
        for (NamedDataSource dataSource : dataSources) {
            ConnectionWrapper connection = dataSourceId_connection.get(dataSource.getName());
            if (connection == null) {
                Connection orgConnection = (Connection) createMethodInvocation.invoke(dataSource);
                connection = new ConnectionWrapper(dataSource, orgConnection);
                invocationRecorder.replay(connection);
                ConnectionWrapper existConnection = dataSourceId_connection.putIfAbsent(dataSource.getName(), connection);
                if (existConnection != null) {
                    connection = existConnection;
                }
            }
            targetConnection.add(connection);
        }
        return targetConnection;
    }

    public List<ConnectionWrapper> route(String sql) {
        return route(routingDataSource.route(sql));
    }

    public List<ConnectionWrapper> route(PreparedStatement preparedStatement) {
        return route(routingDataSource.route(preparedStatement));
    }


    private MethodInvocation reference(Class[] paramsType, Object... params) {
        String methodName = Thread.currentThread().getStackTrace()[2].getMethodName();
        return invocationRecorder.reference(Connection.class, methodName, paramsType, params);
    }

    private void record(Class[] paramsType, Object... params) {
        String methodName = Thread.currentThread().getStackTrace()[2].getMethodName();
        invocationRecorder.record(Connection.class, methodName, paramsType, params);
    }
}
